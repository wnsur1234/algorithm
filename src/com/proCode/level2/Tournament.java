package com.proCode.level2;

import java.util.Scanner;

public class Tournament {
    public static void main(String[] args) {
        /*
        [문제 설명]
        N명의 참가자 -> (1,2) , (3,4) , .... , (N-1, N) 진행
        다음 진출 -> 다시 1부터 N/2의 번호를 받게 됨

        [상황]
        첫 라운드에서 A참가자가 라이벌인 B와 몇번째로 만나는지 궁금
        게임 참가자 수 : N
        참가자 번호 : A
        경쟁자 번호 : B
        매개변수로 주어짐 (단, A,B는 무조건 이김)
        제한 : 2^1 <= N <= 2^20

        [예시]
        입출력 : N = 8, A = 4, B = 7 , 답 : 3
        * */

        // 초기 매개 변수 받기
        Scanner sc = new Scanner(System.in);
        System.out.print("참가자 수를 입력하시오. : ");
        int N = sc.nextInt();
        System.out.print("A의 번호를 입력하시오. : ");
        int A = sc.nextInt();
        System.out.print("B의 번호를 입력하시오. : ");
        int B = sc.nextInt();


        int answer = solution(N,A,B);
        System.out.println(answer);
    }

    /*
    [내 생각]
    1열 : 1,2 3,4 5,6 7,8  --- N까지 n과 n+1
    2열 : 1or2, 3or4 | 5or6, 7or8 ---- N/2까지 n과 n+1
    갑자기 든 생각 : 이거 List로 담아야하나?
    리스트의 배열은 동일하고 안의 값은 달라지니까 그 값이랑 비교할때 answer인거지 i의 값으로

    여기서는 이겨야 올라간다는 표현을 했는데 어차피 A와 B의 값은 이걸 사용할때의 수를 확인하면 될꺼같고
    결국 N까지 n과 n+1을 비교하는것에 관해서 공식을 찾아야함
    TODO: 자료구조 다시 복습하기 (최대 2시간)

    N은 무조건짝수, -> N의 값에 따라 최대 대진 수는? 2 -> 1 : 1번, 4 -> 2 -> 1 : 2번, 8 -> 4 -> 2 -> 1 : 3번, 16 -> 8 -> 4 -> 2 -> 1 : 4번
    step1. 홀,짝 묶는다
    step2. 경우의 수 A,B가 짝수일때 | A가 짝수 B가 홀수 | A가 홀수 B가 짝수
    -> 1번에는 만날수가없음 | 만날가능성 O | 만날가능성 O
    Step3.
    while문으로 나눈값이 1이 될때 braek하고
    N의 값에 따라
    1회 수행 비교해야하는 사항? 2개씩 묶는다?
    2회 수행
    3회 수행
    N /= 2 == 1 break

    ---
    찾아보니 1,2 -> 1 3,4 -> 2 이런식이기 때문에
    다음대진으로 묶음들이 정해지는 번호의 공식을 찾아야함
    근데 그게 a+1/2, b+1/2 라는데 흠... 왜지?

    1+x && 2+x  ==  1
    2/2 3/2 몫을 말하는건가?
    * */
    private static int solution(int N, int A, int B) {
        int result = 0;

        while(true){
            A = (A+1)/2;
            B = (B+1)/2;
            if(A==B){
                result++;
                break;
            }
            result++;
        }
        return result;
    }
}

/*
class Solution
{
    public int solution(int n, int a, int b)
    {
        return Integer.toBinaryString((a-1)^(b-1)).length();
    }
}
이렇게 푼사람이있더라고 이건 이해를 못하겠어

이 풀이는 “토너먼트”를 완전 이진트리(Bracket Tree) 로 보고, 참가자 번호를 이진수 경로로 해석하는 비트 트릭이에요. 한 줄로 요약하면:

a와 b가 만나는 라운드 = (a-1)과 (b-1)의 이진수에서 “처음으로 달라지는(가장 높은) 비트 위치 + 1”
그걸 XOR로 찾고, 그 XOR의 비트 길이가 곧 라운드 수가 됩니다.

아래를 차근차근 보면 “왜 XOR 길이”가 답인지 이해돼요.

1) 왜 (a-1), (b-1) 을 쓰나? (0-index로 맞추기)

토너먼트는 (1,2), (3,4)처럼 2개씩 묶는 그룹핑이 반복되죠.

이걸 0부터 시작하는 인덱스로 바꾸면 그룹핑이 훨씬 깔끔해져요.

참가자 x의 “다음 라운드 번호”는 (x+1)//2였죠.

그런데 0-index로 보면, “부모로 올라가기”가 그냥 오른쪽 쉬프트(>> 1) 가 됩니다.

예를 들어 0-index i에 대해:

다음 라운드(부모) = i >> 1

그 다음 = (i >> 1) >> 1 = i >> 2

k라운드 올라가면 = i >> k

그래서 a-1, b-1로 바꾸는 게 핵심이에요.

2) “몇 라운드째에 만난다”를 비트로 바꾸면?

0-index에서 a와 b가 k라운드째에 만난다는 건:

(a-1) >> k == (b-1) >> k 가 처음으로 성립하는 k

즉, 둘을 계속 오른쪽으로 밀다 보면(=라운드 올리기), 어느 순간 같은 값이 되는데
그때가 만나는 라운드입니다.

3) XOR가 “어디서 다른지”를 알려준다

x ^ y(XOR)는 두 값이 다른 비트가 1이 돼요.

x와 y가 완전히 같으면 XOR = 0

어디가 다른지(특히 “가장 높은 자리에서 언제 처음 달라지는지”)를 XOR가 표시해줍니다.

그리고 중요한 사실:

x와 y를 오른쪽으로 k번 밀어서 같아지려면
x와 y의 “서로 다른 비트들”이 전부 k번 밀려서 사라져야 합니다.

즉, x^y에서 1로 켜진 비트들 중 가장 높은 비트 위치가 “몇 번 밀어야 없어지는지”를 결정해요.

4) XOR의 “이진수 길이”가 왜 라운드 수인가?

어떤 양의 정수 v에 대해:

v의 이진수 길이 = floor(log2(v)) + 1

이건 곧 “가장 높은 1비트의 위치(0부터) + 1”과 같아요.

여기서 v = (a-1) ^ (b-1) 라고 하면,

v의 가장 높은 1비트 위치 = a-1과 b-1이 처음으로 갈라지는(가장 높은) 비트

그 위치 + 1 = 몇 번 >> 해야 같은 값이 되는지 = 만나는 라운드

그래서:

Integer.toBinaryString((a-1)^(b-1)).length()


이게 정답 라운드가 됩니다.

5) 예시로 확인 (a=4, b=7)

a-1 = 3 = 011

b-1 = 6 = 110

XOR = 101 (5)

이진수 길이 = 3

→ 3라운드에서 만남 (실제로도 4와 7은 3라운드에서 만나요)

6) 이 풀이가 “라운드 수”를 정확히 주는 이유를 한 문장으로

만나는 라운드는 “둘의 0-index 번호를 이진수로 봤을 때, 가장 높은 자리에서 갈라지는 지점”으로 결정되고, XOR의 비트 길이가 그 지점을 바로 알려주기 때문입니다.

7) 참고: 문자열로 바꾸지 않는 버전 (같은 원리)

문자열 길이 대신 비트 연산으로도 바로 구할 수 있어요:

int x = (a-1) ^ (b-1);
return 32 - Integer.numberOfLeadingZeros(x);


이 값이 바로 “이진수 길이”와 동일합니다.

원하시면, 지금 n과 a,b 값 하나만 주시면(예: n=16 a=?? b=??)
그 값으로 이진수로 직접 써서 “어디서 갈라져서 몇 라운드인지” 같이 한 번에 납득되게 계산해드릴게요.
* */


